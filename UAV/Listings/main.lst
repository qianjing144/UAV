C251 COMPILER V5.60.0,  main                                                               31/07/24  22:43:51  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE Code\main.c XSMALL ROM(HUGE) BROWSE INCDIR(.\Code;.\Debugware) DEBUG P
                    -RINT(.\Listings\main.lst) OBJECT(.\Objects\main.obj) 

stmt  level    source

    1          #include <STC8051U.H>
    2          #include <intrins.h>
    3          #include <math.h>
    4          #include "main.h"
    5          #include "i2c.h"
    6          #include "lps22hh.h"
    7          #include "UART.h"
    8          #include "sbus.h"
    9          #include "mpu6050.h"
   10          #include "qmc5883l.h"
   11          #include "motor.h"
   12          #include "pid.h"
   13          #include "timer.h"
   14          
   15          #define LU 50
   16          #define HU 110
   17          
   18          #ifdef DEBUG
               #include "OLED.h"
               #endif
   21          
   22          LPS22HH_t lps22hh_obj;
   23          MPU6050_t mpu6050_obj;
   24          QMC5883L_t qmc5883l_obj;
   25          
   26          float targetAngleX=0.0f;
   27          float targetAngleY=0.0f;
   28          float targetYaw=0.0f;
   29          float targetHeight=0.0f;
   30          
   31          float u1=0.0f;
   32          float u2=0.0f;
   33          float u3=0.0f;
   34          float u4=0.0f;
   35          
   36          void delayxus(unsigned int xus) //@11.0592MHz
   37          {
   38   1              unsigned long edata i;
   39   1              unsigned char j=0;
   40   1              while(xus--)
   41   1              {
   42   2                      for(j=0;j<13;j++)
   43   2                      {
   44   3                              _nop_();
   45   3                              _nop_();
   46   3                              _nop_();
   47   3                              i = 4UL;
   48   3                              while (i) i--;
   49   3                      }
   50   2              }
   51   1      }
   52          
   53          void delayxms(unsigned int xms) //@11.0592MHz
   54          {
   55   1              unsigned long edata i;
   56   1              unsigned char j=0;
   57   1              while(xms--)
   58   1              {
C251 COMPILER V5.60.0,  main                                                               31/07/24  22:43:51  PAGE 2   

   59   2                      for(j=0;j<13;j++)
   60   2                      {
   61   3                              _nop_();
   62   3                              _nop_();
   63   3                              i = 2763UL;
   64   3                              while (i) i--;
   65   3                      }
   66   2              }
   67   1      }
   68          
   69          void sys_cfg2()
   70          {
   71   1              P_SW2=0x80;
   72   1              CKCON=0x00;
   73   1              WTST=0x00;
   74   1              
   75   1      //      P0M0= 0x00;
   76   1      //      P0M1= 0x00;
   77   1                  
   78   1              P0M0 = 0xff; 
   79   1              P0M1 = 0x00; 
   80   1      
   81   1              P1M0= 0x00;
   82   1              P1M1= 0x00;
   83   1              P2M0 = 0x18; 
   84   1              P2M1 = 0x18; 
   85   1      
   86   1              P3M0= 0x00;
   87   1              P3M1= 0x00;
   88   1              P4M0= 0x00;
   89   1              P4M1= 0x00;
   90   1              P5M0= 0x00;
   91   1              P5M1= 0x00;
   92   1              
   93   1      //      CLKSEL &= ~0x80; //PLL 96M
   94   1              
   95   1              XOSCCR=0xE4;//启动外部晶振
   96   1              while(!(XOSCCR&1));//等待时钟稳定
   97   1              CLKDIV=0x00;//时钟不分频
   98   1              CLKSEL=0x01;//选择外部晶振
   99   1              
  100   1              CLKSEL &= ~0x80;//选择PLL的96M作为PLL的输出时钟
  101   1              USBCLK &= ~0x60;//
  102   1              USBCLK|=0x00;//PPL输入时钟为12M,选择1分频
  103   1              
  104   1              USBCLK|=0x80;//启动PLL
  105   1              
  106   1              delayxus(60);
  107   1              
  108   1              HSCLKDIV=0x00;
  109   1              CLKSEL|=0x40;
  110   1              TFPU_CLKDIV=0x00;//96M
  111   1              PWMA_CLKDIV=4;//24M
  112   1      }
  113          
  114          void hardware_init()
  115          {
  116   1              uart1_init();
  117   1              i2c_init();
  118   1              
  119   1              timer3_init();
  120   1              delayxms(200);
  121   1      #ifdef DEBUG
                       OLED_Init();
                       OLED_Clear();
               #endif
C251 COMPILER V5.60.0,  main                                                               31/07/24  22:43:51  PAGE 3   

  125   1              
  126   1              
  127   1              
  128   1              lps22hh_obj.devAddr=0x5C;
  129   1              if(lps22hh_init(&lps22hh_obj))
  130   1              {
  131   2                      #ifdef DEBUG
                               OLED_ShowString(0, 0, "E_LPS22HH", 16, 0);
                               #endif
  134   2                      return;
  135   2              }
  136   1              mpu6050_obj.devAddr=0x68;
  137   1              if(mpu6050_init(&mpu6050_obj))
  138   1              {
  139   2                      #ifdef DEBUG
                               OLED_ShowString(0, 0, "E_MPU6050", 16, 0);
                               #endif
  142   2                      return;
  143   2              }
  144   1              qmc5883l_obj.devAddr=0x0D;
  145   1              if(qmc5883l_init(&qmc5883l_obj))
  146   1              {
  147   2                      #ifdef DEBUG
                               OLED_ShowString(0,0, "E_QMC5883l", 16,0);
                               #endif
  150   2                      return;
  151   2              }
  152   1              motor_init();
  153   1              sbus_init();
  154   1              
  155   1      }
  156          void AngleXY()
  157          {
  158   1              static float pX=0.75;//0.5 横滚
  159   1              static float iX=0;
  160   1              static float dX=-0.15;//0.3
  161   1              static float uX=0.0;
  162   1              //X￿?????????????????????????????????????????????????????????????????????
  163   1              float RTAngleX=0;//定义X轴实时角度变￿?????????????????????????????????????????????????????????
             -????????????
  164   1              float RTGyroX=0;//定义X轴实时角速度变量
  165   1      
  166   1              static float pY=0;
  167   1              static float iY=0;
  168   1              static float dY=0;
  169   1              static float uY=0;
  170   1              //Y￿?????????????????????????????????????????????????????????????????????
  171   1              float RTAngleY=0;//定义Y轴实时角度变￿?????????????????????????????????????????????????????????
             -????????????
  172   1              float RTGyroY=0;//定义Y轴实时角速度变量
  173   1              
  174   1              if(mpu6050_getAngleGn(&mpu6050_obj, &RTAngleX, &RTAngleY,&RTGyroX,&RTGyroY)==0)
  175   1              {
  176   2                      uX=-pid_angleX(targetAngleX+8, RTAngleX, RTGyroX, pX, iX, dX);
  177   2                      uY=pid_angleY(targetAngleY, RTAngleY, RTGyroY, pY, iY, dY);
  178   2              }
  179   1              #ifdef DEBUG
                       {
                               static unsigned char oled_i=0;
                               if(oled_i++ >= 100)
                               {
                                       OLED_Showdecimal(0,0,RTAngleX,3,2,12, 0);
                                       oled_i=0;
                               }
                                       
                       }
C251 COMPILER V5.60.0,  main                                                               31/07/24  22:43:51  PAGE 4   

                       
                       #endif
  191   1      //      if(RTAngleX>45 || RTAngleX<-45 || RTAngleY>45 || RTAngleY<-45)
  192   1      //      {
  193   1      //              while(1)
  194   1      //              {
  195   1      //                      #ifdef DEBUG
  196   1      //                      OLED_Showdecimal(0,0,RTAngleX,3,2,12, 0);
  197   1      //                      OLED_Showdecimal(0,1,RTAngleY,3,2,12, 0);
  198   1      //                      #endif
  199   1      //                      motor_control(0,0,0,0);
  200   1      //              }
  201   1      //      }
  202   1              //1+
  203   1              u1+=uY;
  204   1              //2-
  205   1              u2-=uY;
  206   1              //3-
  207   1              u3-=uY;
  208   1              //4+
  209   1              u4+=uY;
  210   1      
  211   1              //1+
  212   1              u1+=uX;
  213   1              //2+
  214   1              u2+=uX;
  215   1              //3-
  216   1              u3-=uX;
  217   1              //4-
  218   1              u4-=uX;
  219   1      }
  220          
  221          void Yaw()
  222          {
  223   1              static float p=0;
  224   1              static float i=0;
  225   1              static float d=0;
  226   1              static float u=0;
  227   1      
  228   1              static unsigned char is_first_flag=1;//第一次运行标志位
  229   1              static float RTYaw=0;//定义存储实时真实的角度的变量
  230   1              static float dRTYaw=0;//存储实时相对起始点的偏航￿?????????????????????????????????????
  231   1              static float startYaw=0;//起始偏航￿?????????????????????????????????????
  232   1      
  233   1              if(qmc5883l_getHeading(&qmc5883l_obj, &RTYaw)==0)
  234   1              {
  235   2                      if(is_first_flag==1)
  236   2                      {
  237   3                              is_first_flag=0;
  238   3                              startYaw=RTYaw;//获取初始高度
  239   3                      }
  240   2                      dRTYaw=RTYaw-startYaw;
  241   2                      u=pid_yaw(targetYaw, dRTYaw, p, i, d);
  242   2              }
  243   1              u1+=u;
  244   1              u2-=u;
  245   1              u3+=u;
  246   1              u4-=u;
  247   1      }
  248          
  249          void Height()
  250          {
  251   1              /* USER CODE BEGIN HeightTask */
  252   1              static float p=0;
  253   1              static float i=0;
  254   1              static float d=0;
C251 COMPILER V5.60.0,  main                                                               31/07/24  22:43:51  PAGE 5   

  255   1              static float u=0;
  256   1      
  257   1              static unsigned char is_first_flag=1;
  258   1              static float StartAltitude=0;
  259   1              float RTHeight=0;
  260   1              float RTAltitude=0;
  261   1              if(lps22hh_get_alt(&lps22hh_obj,&RTAltitude)==0)
  262   1              {
  263   2                      if(is_first_flag==1)
  264   2                      {
  265   3                              is_first_flag=0;
  266   3                              StartAltitude=RTAltitude;//获取初始高度
  267   3                      }
  268   2                      RTHeight=RTAltitude-StartAltitude;//计算相对于起始点的高￿??????????????????????????????????
             -??????????????????????
  269   2                      u=pid_height(targetHeight,RTHeight,p,i,d);//高度调整
  270   2              }
  271   1              u1+=u;
  272   1              u2=u3=u4=u1;
  273   1      }
  274          
  275          void rx()
  276          {
  277   1              static unsigned char kX=0,kY=0,kYaw=0,kHeight=0;
  278   1              #ifdef DEBUG
               //      OLED_ShowNum(0, 0, sbus_getData(5), 5, 12, 0);
                       #endif
  281   1              for(;sbus_getData(5)<800;)
  282   1              {
  283   2                      motor_control(0,0,0,0);
  284   2              }
  285   1              
  286   1              /*
  287   1               * 积分清零
  288   1               */
  289   1              pid_setAngleXI(0);
  290   1              pid_setAngleYI(0);
  291   1              pid_setHeightI(0);
  292   1              pid_setYawI(0);
  293   1              /*
  294   1               * 姿�?�调￿??????????????????????????
  295   1               */
  296   1              targetAngleX=kX*sbus_getData(0);//X
  297   1              targetAngleY=kY*sbus_getData(1);//Y
  298   1              targetYaw+=kYaw*sbus_getData(3);//yaw
  299   1              if(targetYaw>360)//如果转动超过￿?????????????????????????????????????????????????????￿????????
             -?????????????????????????????????????????????
  300   1              {
  301   2                      targetYaw=0;//将目标偏航角度置0,即启动新的一￿??????????????????????????????????????????
             -???????????
  302   2              }
  303   1              else if (targetYaw<0)//如果目标角度小于0
  304   1              {
  305   2                      targetYaw=360;//启动新的￿?????????????????????????????????????????????????????￿????????????????
             -?????????????????????????????????????
  306   2              }
  307   1              targetHeight+=kHeight*sbus_getData(2);//height
  308   1      }
  309          
  310          void u_limit()
  311          {
  312   1              if(u1<LU)
  313   1              {
  314   2                      u1=LU;
  315   2              }
  316   1              else if(u1>HU)
C251 COMPILER V5.60.0,  main                                                               31/07/24  22:43:51  PAGE 6   

  317   1              {
  318   2                      u1=HU;
  319   2              }
  320   1              if(u2<LU)
  321   1              {
  322   2                      u2=LU;
  323   2              }
  324   1              else if(u2>HU)
  325   1              {
  326   2                      u2=HU;
  327   2              }
  328   1              if(u3<LU)
  329   1              {
  330   2                      u3=LU;
  331   2              }
  332   1              else if(u3>HU)
  333   1              {
  334   2                      u3=HU;
  335   2              }
  336   1              if(u4<LU)
  337   1              {
  338   2                      u4=LU;
  339   2              }
  340   1              else if(u4>HU)
  341   1              {
  342   2                      u4=HU;
  343   2              }
  344   1      }
  345          
  346          void motor_run()
  347          {
  348   1              motor_1(u1*0.905);
  349   1              motor_2(u2);
  350   1              motor_3(u3);
  351   1              motor_4(u4);
  352   1              u1=LU;
  353   1              u2=LU;
  354   1              u3=LU;
  355   1              u4=LU;
  356   1      }
  357          
  358          void main()
  359          {
  360   1              sys_cfg2();
  361   1              EA=1;
  362   1              hardware_init();
  363   1              
  364   1              while(1)
  365   1              {
  366   2                      AngleXY();
  367   2                      
  368   2      //              Yaw();
  369   2      //              Height();
  370   2                      
  371   2                      rx();
  372   2                      
  373   2                      u_limit();
  374   2                      #ifdef DEBUG
               //              OLED_Showdecimal(0,0,u1,3,2,12, 0);
                               #endif
  377   2                      motor_run();
  378   2              }
  379   1      }
  380          
  381          
  382          void uart2_isr(void) interrupt 8
C251 COMPILER V5.60.0,  main                                                               31/07/24  22:43:51  PAGE 7   

  383          {
  384   1              if (S2CON & 0x02)       //检测串口2发送中断
  385   1              {
  386   2                      S2CON &= ~0x02; //清除串口2发送中断请求位
  387   2              }
  388   1              if (S2CON & 0x01)       //检测串口2接收中断
  389   1              {
  390   2                      RI=0;
  391   2                      sbus_setRxCnt(sbus_getRxCnt()+1);
*** WARNING C188 IN LINE 391 OF Code\main.c: 'parameter 1': value truncated
  392   2                      if(sbus_getRxCnt()>=24)sbus_setRxCnt(0);
  393   2                      sbus_setRx2TimeOut(5);
  394   2                      S2CON &= ~0x01; //清除串口2接收中断请求位
  395   2              }
  396   1      }
  397          
  398          void timer3_isr(void) interrupt 19
  399          {
  400   1              if(sbus_getRx2TimeOut()>0)
  401   1              {
  402   2                      sbus_setRx2TimeOut(sbus_getRx2TimeOut()-1);
*** WARNING C188 IN LINE 402 OF Code\main.c: 'parameter 1': value truncated
  403   2                      if(sbus_getRx2TimeOut()==0)
  404   2                      {
  405   3                              DMA_UR2R_CR=0x00;
  406   3                              sbus_setRxCnt(0);
  407   3                              DMA_UR2R_CR=0xA1;
  408   3                      }
  409   2              }
  410   1      }
  411          
  412          void SBUS_DMA_Isr(void) interrupt 53
  413          {
  414   1              
  415   1              if(DMA_UR2R_STA&0x01)
  416   1              {
  417   2                      #ifdef DEBUG
               //              OLED_ShowNum(0,2,8,3,12,0);
                               #endif
  420   2                      DMA_UR2R_STA &= ~0x01;
  421   2                      sbus_inirq();
  422   2                      sbus_setRxCnt(0);
  423   2                      sbus_setRx2TimeOut(0);
  424   2                      DMA_UR2R_CR=0xA1;
  425   2              }
  426   1                      
  427   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =        12     ------
  ecode size           =      1625     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       121         20
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       254     ------
C251 COMPILER V5.60.0,  main                                                               31/07/24  22:43:51  PAGE 8   

End of Module Information.


C251 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
