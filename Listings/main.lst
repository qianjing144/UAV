C251 COMPILER V5.60.0,  main                                                               10/08/24  08:39:09  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE Code\main.c XSMALL ROM(HUGE) BROWSE INCDIR(.\Code;.\Debugware) DEBUG P
                    -RINT(.\Listings\main.lst) OBJECT(.\Objects\main.obj) 

stmt  level    source

    1          #include <STC8051U.H>
    2          #include <intrins.h>
    3          #include <math.h>
    4          #include "main.h"
    5          #include "i2c.h"
    6          #include "lps22hh.h"
    7          #include "UART.h"
    8          #include "sbus.h"
    9          #include "mpu6050.h"
   10          #include "qmc5883l.h"
   11          #include "motor.h"
   12          #include "pid.h"
   13          #include "timer.h"
   14          
   15          #define LU 45
   16          #define HU 110
   17          
   18          #ifdef DEBUG
               #include "OLED.h"
               #endif
   21          
   22          LPS22HH_t lps22hh_obj;
   23          MPU6050_t mpu6050_obj;
   24          QMC5883L_t qmc5883l_obj;
   25          
   26          float targetAngleX=0.0f;
   27          float targetAngleY=0.0f;
   28          float targetYaw=0.0f;
   29          float targetHeight=0.0f;
   30          
   31          float u1=0.0f;
   32          float u2=0.0f;
   33          float u3=0.0f;
   34          float u4=0.0f;
   35          
   36          void delayxus(unsigned int xus) //@11.0592MHz
   37          {
   38   1              unsigned long edata i;
   39   1              unsigned char j=0;
   40   1              while(xus--)
   41   1              {
   42   2                      for(j=0;j<13;j++)
   43   2                      {
   44   3                              _nop_();
   45   3                              _nop_();
   46   3                              _nop_();
   47   3                              i = 4UL;
   48   3                              while (i) i--;
   49   3                      }
   50   2              }
   51   1      }
   52          
   53          void delayxms(unsigned int xms) //@11.0592MHz
   54          {
   55   1              unsigned long edata i;
   56   1              unsigned char j=0;
   57   1              while(xms--)
   58   1              {
C251 COMPILER V5.60.0,  main                                                               10/08/24  08:39:09  PAGE 2   

   59   2                      for(j=0;j<13;j++)
   60   2                      {
   61   3                              _nop_();
   62   3                              _nop_();
   63   3                              i = 2763UL;
   64   3                              while (i) i--;
   65   3                      }
   66   2              }
   67   1      }
   68          
   69          void sys_cfg2()
   70          {
   71   1              P_SW2=0x80;
   72   1              CKCON=0x00;
   73   1              WTST=0x00;
   74   1              
   75   1      //      P0M0= 0x00;
   76   1      //      P0M1= 0x00;
   77   1                  
   78   1              P0M0 = 0xff; 
   79   1              P0M1 = 0x00; 
   80   1      
   81   1              P1M0= 0x00;
   82   1              P1M1= 0x00;
   83   1              P2M0 = 0x18; 
   84   1              P2M1 = 0x18; 
   85   1      
   86   1              P3M0= 0x00;
   87   1              P3M1= 0x00;
   88   1              P4M0= 0x00;
   89   1              P4M1= 0x00;
   90   1              P5M0= 0x00;
   91   1              P5M1= 0x00;
   92   1              
   93   1      //      CLKSEL &= ~0x80; //PLL 96M
   94   1              
   95   1              XOSCCR=0xE4;//启动外部晶振
   96   1              while(!(XOSCCR&1));//等待时钟稳定
   97   1              CLKDIV=0x00;//时钟不分频
   98   1              CLKSEL=0x01;//选择外部晶振
   99   1              
  100   1              CLKSEL &= ~0x80;//选择PLL的96M作为PLL的输出时钟
  101   1              USBCLK &= ~0x60;//
  102   1              USBCLK|=0x00;//PPL输入时钟为12M,选择1分频
  103   1              
  104   1              USBCLK|=0x80;//启动PLL
  105   1              
  106   1              delayxus(60);
  107   1              
  108   1              HSCLKDIV=0x00;
  109   1              CLKSEL|=0x40;
  110   1              TFPU_CLKDIV=0x00;//96M
  111   1              PWMA_CLKDIV=4;//24M
  112   1      }
  113          
  114          void hardware_init()
  115          {
  116   1              EA=1;
  117   1              uart1_init();
  118   1              i2c_init();
  119   1              timer3_init();  
  120   1              sbus_init();
  121   1              delayxms(200);
  122   1      #ifdef DEBUG
                       OLED_Init();
                       OLED_Clear();
C251 COMPILER V5.60.0,  main                                                               10/08/24  08:39:09  PAGE 3   

               #endif
  126   1              lps22hh_obj.devAddr=0x5C;
  127   1              while(lps22hh_init(&lps22hh_obj))
  128   1              {
  129   2                      #ifdef DEBUG
                               OLED_ShowString(0, 0, "E_LPS22HH", 16, 0);
                               #endif
  132   2                      return;
  133   2              }
  134   1              mpu6050_obj.devAddr=0x68;
  135   1              while(mpu6050_init(&mpu6050_obj))
  136   1              {
  137   2                      #ifdef DEBUG
                               OLED_ShowString(0, 0, "E_MPU6050", 16, 0);
                               #endif
  140   2                      return;
  141   2              }
  142   1              qmc5883l_obj.devAddr=0x0D;
  143   1              while(qmc5883l_init(&qmc5883l_obj))
  144   1              {
  145   2                      #ifdef DEBUG
                               OLED_ShowString(0,0, "E_QMC5883l", 16,0);
                               #endif
  148   2                      return;
  149   2              }
  150   1              motor_init();
  151   1              Timer4_Init();
  152   1      }
  153          
  154          unsigned char AngleXY()
  155          {
  156   1              static float pAX=0;
  157   1              static float iAX=0;
  158   1              static float dAX=0;
  159   1      
  160   1              static float pGX=0;//0.5 横滚
  161   1              static float iGX=0;
  162   1              static float dGX=0;//0.3
  163   1      
  164   1              static float uX=0.0;
  165   1              //X�??????????????????????????????????????????????????????????????????????????
  166   1              float RTAngleX=0;//定义X轴实时角度变�?????????????????????????????????????????????????????????
             -?????????????????
  167   1              float RTGyroX=0;//定义X轴实时角速度变量
  168   1      
  169   1              static float pAY=-1;
  170   1              static float iAY=0;
  171   1              static float dAY=0;
  172   1      
  173   1              static float pGY=-0.3;//0.3最好
  174   1              static float iGY=0;
  175   1              static float dGY=0;
  176   1      
  177   1              static float uY=0;
  178   1              //Y�??????????????????????????????????????????????????????????????????????????
  179   1              float RTAngleY=0;//定义Y轴实时角度变�?????????????????????????????????????????????????????????
             -?????????????????
  180   1              float RTGyroY=0;//定义Y轴实时角速度变量
  181   1      
  182   1              if(mpu6050_getAngleGn(&mpu6050_obj, &RTAngleX, &RTAngleY,&RTGyroX,&RTGyroY))
  183   1              {
  184   2                      return 1;
  185   2              }
  186   1              uX=pid_angleX(targetAngleX, RTAngleX, RTGyroX, pAX, iAX, dAX);
  187   1              uX=pid_gyroX(uX,RTGyroX,pGX,iGX,dGX);
  188   1              uY=pid_angleY(targetAngleY, RTAngleY, RTGyroY, pAY, iAY, dAY);
C251 COMPILER V5.60.0,  main                                                               10/08/24  08:39:09  PAGE 4   

  189   1      //      OLED_Showdecimal(0,0,uY,3,2,12,0);
  190   1              uY=pid_gyroY(uY,RTGyroY-13,pGY,iGY,dGY);
  191   1              
  192   1              //1+
  193   1              u1+=uX;
  194   1              //2+
  195   1              u2+=uX;
  196   1              //3-
  197   1              u3-=uX;
  198   1              //4-
  199   1              u4-=uX;
  200   1              
  201   1              
  202   1              //1+
  203   1              u1+=uY;
  204   1              //2-
  205   1              u2-=uY;
  206   1              //3-
  207   1              u3-=uY;
  208   1              //4+
  209   1              u4+=uY;
  210   1              
  211   1              return 0;
  212   1      }
  213          
  214          unsigned char Yaw()
  215          {
  216   1              static float p=0;
  217   1              static float i=0;
  218   1              static float d=0;
  219   1              static float u=0;
  220   1      
  221   1              static unsigned char is_first_flag=1;//第一次运行标志位
  222   1              static float RTYaw=0;//定义存储实时真实的角度的变量
  223   1              static float dRTYaw=0;//存储实时相对起始点的偏航￿?????????????????????????????????????
  224   1              static float startYaw=0;//起始偏航￿?????????????????????????????????????
  225   1      
  226   1              if(qmc5883l_getHeading(&qmc5883l_obj, &RTYaw))
  227   1              {
  228   2                      return 1;
  229   2              }
  230   1              if(is_first_flag==1)
  231   1              {
  232   2                      is_first_flag=0;
  233   2                      startYaw=RTYaw;//获取初始高度
  234   2              }
  235   1              dRTYaw=RTYaw-startYaw;
  236   1              u=pid_yaw(targetYaw, dRTYaw, p, i, d);
  237   1              u1+=u;
  238   1              u2-=u;
  239   1              u3+=u;
  240   1              u4-=u;
  241   1              return 0;
  242   1      }
  243          
  244          void Height()
  245          {
  246   1              /* USER CODE BEGIN HeightTask */
  247   1              static float p=0;
  248   1              static float i=0;
  249   1              static float d=0;
  250   1              static float u=0;
  251   1      
  252   1              static unsigned char is_first_flag=1;
  253   1              static float StartAltitude=0;
  254   1              float RTHeight=0;
C251 COMPILER V5.60.0,  main                                                               10/08/24  08:39:09  PAGE 5   

  255   1              float RTAltitude=0;
  256   1              if(lps22hh_get_alt(&lps22hh_obj,&RTAltitude)==0)
  257   1              {
  258   2                      if(is_first_flag==1)
  259   2                      {
  260   3                              is_first_flag=0;
  261   3                              StartAltitude=RTAltitude;//获取初始高度
  262   3                      }
  263   2                      RTHeight=RTAltitude-StartAltitude;//计算相对于起始点的高￿??????????????????????????????????
             -??????????????????????
  264   2                      u=pid_height(targetHeight,RTHeight,p,i,d);//高度调整
  265   2              }
  266   1              u1+=u;
  267   1              u2+=u;
  268   1              u3+=u;
  269   1              u4+=u;
  270   1      }
  271          
  272          void rx()
  273          {
  274   1              static unsigned char kX=0,kY=0,kYaw=0,kHeight=0;
  275   1              for(;sbus_getData(5)<800;)
  276   1              {
  277   2                      motor_control(0,0,0,0);
  278   2              }
  279   1              
  280   1              /*
  281   1               * 积分清零
  282   1               */
  283   1              pid_setAngleXI(0);
  284   1              pid_setAngleYI(0);
  285   1              pid_setHeightI(0);
  286   1              pid_setYawI(0);
  287   1              /*
  288   1               * 姿�?�调￿??????????????????????????
  289   1               */
  290   1              targetAngleX=kX*sbus_getData(0);//X
  291   1              targetAngleY=kY*sbus_getData(1);//Y
  292   1              targetYaw+=kYaw*sbus_getData(3);//yaw
  293   1              if(targetYaw>360)//如果转动超过￿?????????????????????????????????????????????????????￿????????
             -?????????????????????????????????????????????
  294   1              {
  295   2                      targetYaw=0;//将目标偏航角度置0,即启动新的一￿??????????????????????????????????????????
             -???????????
  296   2              }
  297   1              else if (targetYaw<0)//如果目标角度小于0
  298   1              {
  299   2                      targetYaw=360;//启动新的￿?????????????????????????????????????????????????????￿????????????????
             -?????????????????????????????????????
  300   2              }
  301   1              targetHeight+=kHeight*sbus_getData(2);//height
  302   1      }
  303          
  304          void u_limit()
  305          {
  306   1              if(u1<LU)
  307   1              {
  308   2                      u1=LU;
  309   2              }
  310   1              else if(u1>HU)
  311   1              {
  312   2                      u1=HU;
  313   2              }
  314   1              if(u2<LU)
  315   1              {
  316   2                      u2=LU;
C251 COMPILER V5.60.0,  main                                                               10/08/24  08:39:09  PAGE 6   

  317   2              }
  318   1              else if(u2>HU)
  319   1              {
  320   2                      u2=HU;
  321   2              }
  322   1              if(u3<LU)
  323   1              {
  324   2                      u3=LU;
  325   2              }
  326   1              else if(u3>HU)
  327   1              {
  328   2                      u3=HU;
  329   2              }
  330   1              if(u4<LU)
  331   1              {
  332   2                      u4=LU;
  333   2              }
  334   1              else if(u4>HU)
  335   1              {
  336   2                      u4=HU;
  337   2              }
  338   1      }
  339          
  340          void motor_run()
  341          {
  342   1              motor_1(u1);
  343   1              motor_2(u2);
  344   1              motor_3(u3);
  345   1              motor_4(u4);
  346   1              u1=LU;
  347   1              u2=LU;
  348   1              u3=LU;
  349   1              u4=LU;
  350   1      }
  351          
  352          void main()
  353          {
  354   1              sys_cfg2();
  355   1              hardware_init();
  356   1              while(1)
  357   1              {
  358   2                      
  359   2              }
  360   1      }
  361          
  362          
  363          void uart2_isr(void) interrupt 8
  364          {
  365   1              if (S2CON & 0x02)       //检测串口2发送中断
  366   1              {
  367   2                      S2CON &= ~0x02; //清除串口2发送中断请求位
  368   2              }
  369   1              if (S2CON & 0x01)       //检测串口2接收中断
  370   1              {
  371   2                      RI=0;
  372   2                      sbus_setRxCnt(sbus_getRxCnt()+1);
*** WARNING C188 IN LINE 372 OF Code\main.c: 'parameter 1': value truncated
  373   2                      if(sbus_getRxCnt()>=24)sbus_setRxCnt(0);
  374   2                      sbus_setRx2TimeOut(5);
  375   2                      S2CON &= ~0x01; //清除串口2接收中断请求位
  376   2              }
  377   1      }
  378          
  379          void timer3_isr(void) interrupt 19
  380          {
  381   1              if(sbus_getRx2TimeOut()>0)
C251 COMPILER V5.60.0,  main                                                               10/08/24  08:39:09  PAGE 7   

  382   1              {
  383   2                      sbus_setRx2TimeOut(sbus_getRx2TimeOut()-1);
*** WARNING C188 IN LINE 383 OF Code\main.c: 'parameter 1': value truncated
  384   2                      if(sbus_getRx2TimeOut()==0)
  385   2                      {
  386   3                              DMA_UR2R_CR=0x00;
  387   3                              sbus_setRxCnt(0);
  388   3                              DMA_UR2R_CR=0xA1;
  389   3                      }
  390   2              }
  391   1      }
  392          
  393          void SBUS_DMA_Isr(void) interrupt 53
  394          {
  395   1              
  396   1              if(DMA_UR2R_STA&0x01)
  397   1              {
  398   2                      DMA_UR2R_STA &= ~0x01;
  399   2                      sbus_inirq();
  400   2                      sbus_setRxCnt(0);
  401   2                      sbus_setRx2TimeOut(0);
  402   2                      DMA_UR2R_CR=0xA1;
  403   2              }
  404   1      }
  405          
  406          void Timer4_Isr(void) interrupt 20
  407          {
  408   1              AngleXY();
  409   1      //      OLED_Showdecimal(0,1,u1,3,2,12,0);
  410   1      //      OLED_Showdecimal(0,2,u2,3,2,12,0);
  411   1      //      OLED_Showdecimal(0,3,u3,3,2,12,0);
  412   1      //      OLED_Showdecimal(0,4,u4,3,2,12,0);
  413   1              Yaw();
  414   1              Height();
  415   1              rx();
  416   1              
  417   1              u_limit();
  418   1              
  419   1              motor_run();
  420   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =        16     ------
  ecode size           =      1776     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       145         20
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       302     ------
End of Module Information.


C251 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
