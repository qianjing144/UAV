C251 COMPILER V5.60.0,  PID                                                                10/08/24  08:39:10  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE PID
OBJECT MODULE PLACED IN .\Objects\PID.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE Code\PID.c XSMALL ROM(HUGE) BROWSE INCDIR(.\Code;.\Debugware) DEBUG PR
                    -INT(.\Listings\PID.lst) OBJECT(.\Objects\PID.obj) 

stmt  level    source

    1          /*
    2           * PID.c
    3           *
    4           *  Created on: Jul 13, 2024
    5           *      Author: qian-jing
    6           */
    7          
    8          float Angle_X_I=0;      //å­˜å‚¨Xç›¸å·®è§’åº¦çš„ç´¯è®¡å€¼
    9          float Gyro_X_I=0;
   10          float Angle_Y_I=0;      //å­˜å‚¨Yç›¸å·®è§’åº¦çš„ç´¯è®¡å€¼
   11          float Gyro_Y_I=0;
   12          float Height_I  =0;     //å­˜å‚¨ç›¸å·®é«˜åº¦çš„ç´¯è®¡å€¼
   13          float Yaw_I             =0;     //å®šä¹‰å­˜å‚¨åèˆªè§’åº¦ç´¯è®¡çš„å˜é‡
   14          
   15          float pid_angleX(float TargetAngle,float RTAngle,float RTGyro,float Kp, float Ki,float Kd)
   16          {
   17   1              float Angle=0;
   18   1              Angle=RTAngle-TargetAngle;//è·å–ç›®æ ‡è§’åº¦å’Œç›®å‰è§’åº¦çš„å·®å€¼
   19   1              Angle_X_I+=Angle;               //è§’åº¦ç§¯åˆ†ç´¯ç§¯
   20   1              if(Angle_X_I>30)
   21   1              {
   22   2                      Angle_X_I=30;
   23   2              }
   24   1              return Kp*Angle-Ki*Angle_X_I+Kd*RTGyro;
   25   1      }
   26          float pid_gyroX(float TargetGyro, float RTGyro,float Kp,float Ki,float Kd)
   27          {
   28   1              float Gyro=0;
   29   1              static float PastGyro=0;
   30   1              float Gyro_D=0;
   31   1              Gyro=RTGyro-TargetGyro;
   32   1              Gyro_X_I+=Gyro;
   33   1              if(Gyro_X_I>30)
   34   1              {
   35   2                      Gyro_X_I=30;
   36   2              }
   37   1              Gyro_D=RTGyro-PastGyro;
   38   1              PastGyro=Gyro;
   39   1              return Kp*Gyro-Ki*Angle_X_I+Kd*Gyro_D;
   40   1      }
   41          float pid_angleY(float TargetAngle,float RTAngle,float RTGyro,float Kp, float Ki,float Kd)
   42          {
   43   1              float Angle=0;                                          //å®šä¹‰å­˜å‚¨å½“å‰è§’åº¦çš„å˜é‡
   44   1              Angle=RTAngle-TargetAngle;//è·å–ç›®æ ‡è§’åº¦å’Œç›®å‰è§’åº¦çš„å·®å€¼
   45   1              Angle_Y_I+=Angle;               //è§’åº¦ç§¯åˆ†ç´¯è®¡
   46   1              if(Angle_Y_I>30)
   47   1              {
   48   2                      Angle_Y_I=30;
   49   2              }
   50   1              return Kp*Angle-Ki*Angle_Y_I+Kd*RTGyro; //è¿”å›è°ƒæ•´å€¼ doubleç±»å‹
   51   1      }
   52          float pid_gyroY(float TargetGyro, float RTGyro,float Kp,float Ki,float Kd)
   53          {
   54   1              float Gyro=0;
   55   1              static float PastGyro=0;
   56   1              float Gyro_D=0;
   57   1              Gyro=RTGyro-TargetGyro;
   58   1              Gyro_Y_I+=Gyro;
C251 COMPILER V5.60.0,  PID                                                                10/08/24  08:39:10  PAGE 2   

   59   1              if(Gyro_Y_I>30)
   60   1              {
   61   2                      Gyro_Y_I=30;
   62   2              }
   63   1              Gyro_D=RTGyro-PastGyro;
   64   1              PastGyro=Gyro;
   65   1              return Kp*Gyro-Ki*Angle_Y_I+Kd*Gyro_D;
   66   1      }
   67          float pid_yaw(float TargetYaw,float RTYaw,float Kp,float Ki,float Kd)
   68          {
   69   1              float Yaw=0;                                                                                                    //å®šä¹‰å­˜å‚¨å½“å‰åèˆªè§’åº¦çš„å˜é‡
   70   1              static float PastYaw=0;                                         //å®šä¹‰å­˜å‚¨ä¸Šä¸€æ¬¡è·å¾—çš„åèˆªè§’åº¦çš„å˜é‡
   71   1              float Yaw_D=0;                                                                                  //å®šä¹‰å­˜å‚¨åèˆªè§’åº¦å˜åŒ–é€Ÿåº¦çš„å˜é‡
   72   1              Yaw=RTYaw-TargetYaw;
   73   1              Yaw_D=RTYaw-PastYaw;                                                    //è·å–ç›®æ ‡è§’åº¦ä¸è®¾å®šåèˆªè§’åº¦çš„å·®
   74   1              PastYaw=Yaw;                                                                                            //è®°å½•è¿™ä¸€æ¬¡çš„å˜åŒ–è§’åº¦,å°†åœ¨ä¸‹ä¸€æ¬¡çš„æ—¶å€™ä½œä¸ºä¸Šä¸€æ¬¡çš„åèˆ
             -ªè§’åº¦ä½¿ç”¨,ç”¨äºè®¡ç®—åèˆªè§’åº¦çš„å˜åŒ–é€Ÿåº¦
   75   1              Yaw_I+=Yaw;                                                                                     //ç´¯è®¡è¯¯å·®
   76   1              return Kp*Yaw+Ki*Yaw_I+Kd*Yaw_D;//è¿”å›è°ƒæ•´å€¼ doubleç±»å‹
   77   1      }
   78          float pid_height(float TargetHeight,float RTHeight,float Kp,float Ki,float Kd)
   79          {
   80   1              float Height=0;                                 //å®šä¹‰å­˜å‚¨å½“å‰è§’åº¦çš„å˜é‡
   81   1              static float PastHeight=0;                      //å®šä¹‰å­˜å‚¨ä¸Šä¸€æ¬¡è·å¾—çš„é«˜åº¦çš„å˜é‡
   82   1              float Height_D=0;                               //å®šä¹‰å­˜å‚¨é«˜åº¦å˜åŒ–é€Ÿåº¦çš„å˜é‡
   83   1              Height=RTHeight-TargetHeight;                                                           //è®¡ç®—ç›¸å·®é«˜åº¦
   84   1              Height_D=Height-PastHeight;                                                                     //è®¡ç®—é«˜åº¦å˜åŒ–é‡
   85   1              PastHeight=Height;                                                                                                      //è®°å½•è¿™ä¸€æ¬¡çš„å˜åŒ–é‡,å°†åœ¨ä¸‹ä¸€æ¬¡çš„æ—¶å€™ä½œä¸ºä¸Šä¸€æ¬¡çš„é
             -«˜åº¦ä½¿ç”¨,ç”¨äºè®¡ç®—é«˜åº¦çš„å˜åŒ–é€Ÿåº¦
   86   1              Height_I+=Height;                                                                       //ç´¯è®¡ç›¸å·®è§’åº¦
   87   1      
   88   1              return Kp*Height+Ki*Height_I+Kd*Height_D;//è¿”å›è°ƒæ•´å€¼ doubleç±»å‹
   89   1      }
   90          void pid_setAngleXI(float val)
   91          {
   92   1              Angle_X_I=val;
   93   1      }
   94          void pid_setAngleYI(float val)
   95          {
   96   1              Angle_Y_I=val;
   97   1      }
   98          void pid_setHeightI(float val)
   99          {
  100   1              Height_I=val;
  101   1      }
  102          void pid_setYawI(float val)
  103          {
  104   1              Yaw_I=val;
  105   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =    ------     ------
  ecode size           =       624     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        40         80
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
C251 COMPILER V5.60.0,  PID                                                                10/08/24  08:39:10  PAGE 3   

  const size           =    ------     ------
  hconst size          =        80     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
